// Telegram Ë°®ÊÉÖÂåÖÂà∂‰ΩúÂô® - ÂâçÁ´ØJavaScript

class StickerMaker {
    constructor() {
        this.uploadedFiles = [];
        this.currentTask = null;
        this.config = {};
        
        this.init();
    }
    
    init() {
        this.setupEventListeners();
        this.loadConfig();
        this.setupTabs();
        this.setupFileUpload();
    }
    
    // ‰∫ã‰ª∂ÁõëÂê¨Âô®ËÆæÁΩÆ
    setupEventListeners() {
        // ÈÖçÁΩÆÁõ∏ÂÖ≥
        document.getElementById('config-form').addEventListener('submit', (e) => this.saveConfig(e));
        document.getElementById('test-config').addEventListener('click', () => this.testConfig());
        document.getElementById('refresh-config').addEventListener('click', () => this.loadConfig());
        
        // ‰ª£ÁêÜËÆæÁΩÆÁõ∏ÂÖ≥
        document.getElementById('proxy-enabled').addEventListener('change', (e) => this.toggleProxySettings(e));
        document.getElementById('proxy-auth-enabled').addEventListener('change', (e) => this.toggleProxyAuth(e));
        
        // Êñá‰ª∂‰∏ä‰º†Áõ∏ÂÖ≥
        document.getElementById('file-input').addEventListener('change', (e) => this.handleFileSelect(e));
        document.getElementById('sticker-form').addEventListener('submit', (e) => this.createStickerPack(e));
        
        // Ë°®ÊÉÖÂåÖÁÆ°ÁêÜÁõ∏ÂÖ≥
        document.getElementById('search-pack-btn').addEventListener('click', () => this.searchStickerPack());
        document.getElementById('pack-search').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') this.searchStickerPack();
        });
        
        // Ê®°ÊÄÅÊ°ÜÁõ∏ÂÖ≥
        document.getElementById('save-sticker-edit').addEventListener('click', () => this.saveStickerEdit());
    }
    
    // Ê†áÁ≠æÈ°µËÆæÁΩÆ
    setupTabs() {
        document.querySelectorAll('[data-tab]').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const tab = e.target.closest('[data-tab]').dataset.tab;
                this.switchTab(tab);
            });
        });
    }
    
    switchTab(tabName) {
        // Êõ¥Êñ∞ÂØºËà™
        document.querySelectorAll('[data-tab]').forEach(link => {
            link.classList.remove('active');
        });
        document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
        
        // Êõ¥Êñ∞ÂÜÖÂÆπ
        document.querySelectorAll('.tab-pane').forEach(pane => {
            pane.classList.remove('active');
        });
        document.getElementById(tabName).classList.add('active');
    }
    
    // Êñá‰ª∂‰∏ä‰º†ËÆæÁΩÆ
    setupFileUpload() {
        const uploadZone = document.getElementById('upload-zone');
        const fileInput = document.getElementById('file-input');
        
        // ÊãñÊãΩÂäüËÉΩ
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadZone.addEventListener(eventName, this.preventDefaults, false);
        });
        
        ['dragenter', 'dragover'].forEach(eventName => {
            uploadZone.addEventListener(eventName, () => {
                uploadZone.classList.add('dragover');
            }, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            uploadZone.addEventListener(eventName, () => {
                uploadZone.classList.remove('dragover');
            }, false);
        });
        
        uploadZone.addEventListener('drop', (e) => this.handleDrop(e), false);
        uploadZone.addEventListener('click', () => fileInput.click());
    }
    
    preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }
    
    handleDrop(e) {
        const files = e.dataTransfer.files;
        this.handleFiles(files);
    }
    
    handleFileSelect(e) {
        this.handleFiles(e.target.files);
    }
    
    handleFiles(files) {
        const fileArray = Array.from(files);
        const validFiles = fileArray.filter(file => this.validateFile(file));
        
        if (validFiles.length > 0) {
            this.uploadFiles(validFiles);
        }
    }
    
    validateFile(file) {
        const allowedTypes = ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'video/mp4', 'video/webm'];
        const maxSize = 50 * 1024 * 1024; // 50MB
        
        if (!allowedTypes.includes(file.type)) {
            this.showAlert(`‰∏çÊîØÊåÅÁöÑÊñá‰ª∂Á±ªÂûã: ${file.name}`, 'warning');
            return false;
        }
        
        if (file.size > maxSize) {
            this.showAlert(`Êñá‰ª∂ËøáÂ§ß: ${file.name} (Ë∂ÖËøá50MB)`, 'warning');
            return false;
        }
        
        return true;
    }
    
    async uploadFiles(files) {
        const formData = new FormData();
        files.forEach(file => formData.append('files', file));
        
        try {
            this.showLoading(true);
            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            
            if (result.success) {
                this.uploadedFiles = result.files;
                this.displayUploadedFiles();
                this.updateCreateButton();
                
                if (result.errors.length > 0) {
                    result.errors.forEach(error => this.showAlert(error, 'warning'));
                }
            } else {
                this.showAlert(result.error, 'danger');
            }
        } catch (error) {
            this.showAlert('‰∏ä‰º†Â§±Ë¥•: ' + error.message, 'danger');
        } finally {
            this.showLoading(false);
        }
    }
    
    displayUploadedFiles() {
        const fileList = document.getElementById('file-list');
        const fileItems = document.getElementById('file-items');
        
        if (this.uploadedFiles.length === 0) {
            fileList.style.display = 'none';
            return;
        }
        
        fileList.style.display = 'block';
        fileItems.innerHTML = '';
        
        this.uploadedFiles.forEach((file, index) => {
            const item = document.createElement('div');
            item.className = 'file-item d-flex align-items-center';
            item.innerHTML = `
                <div class="me-3">
                    ${this.getFilePreview(file)}
                </div>
                <div class="flex-grow-1">
                    <h6 class="mb-1">${file.filename}</h6>
                    <small class="text-muted">
                        ${this.formatFileSize(file.size)} ‚Ä¢ ${file.type}
                    </small>
                </div>
                <div>
                    <button class="btn btn-sm btn-outline-danger" onclick="stickerMaker.removeFile(${index})">
                        <i class="bi bi-trash"></i>
                    </button>
                </div>
            `;
            fileItems.appendChild(item);
        });
    }
    
    getFilePreview(file) {
        if (file.type.startsWith('.mp4') || file.type.startsWith('.webm')) {
            return '<i class="bi bi-play-circle file-preview d-flex align-items-center justify-content-center bg-light" style="font-size: 24px;"></i>';
        } else if (file.type.startsWith('.gif')) {
            return `<img src="/uploads/${file.unique_filename}" class="file-preview" alt="È¢ÑËßà">`;
        } else {
            return `<img src="/uploads/${file.unique_filename}" class="file-preview" alt="È¢ÑËßà">`;
        }
    }
    
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    removeFile(index) {
        this.uploadedFiles.splice(index, 1);
        this.displayUploadedFiles();
        this.updateCreateButton();
    }
    
    updateCreateButton() {
        const createBtn = document.getElementById('create-btn');
        createBtn.disabled = this.uploadedFiles.length === 0;
    }
    
    // ÈÖçÁΩÆÁÆ°ÁêÜ
    async loadConfig() {
        try {
            const response = await fetch('/api/config');
            const result = await response.json();
            
            this.config = result.config;
            
            // Êõ¥Êñ∞Ë°®Âçï
            document.getElementById('bot-token').value = this.config.TELEGRAM_BOT_TOKEN || '';
            document.getElementById('user-id').value = this.config.TELEGRAM_USER_ID || '';
            document.getElementById('pack-prefix').value = this.config.PACK_NAME_PREFIX || '';
            document.getElementById('default-emoji-config').value = this.config.DEFAULT_EMOJI || 'üòÄ';
            document.getElementById('default-emoji').value = this.config.DEFAULT_EMOJI || 'üòÄ';
            
            // Êõ¥Êñ∞‰ª£ÁêÜËÆæÁΩÆ
            this.loadProxyConfig(this.config);
            
            // Êõ¥Êñ∞Áä∂ÊÄÅ
            this.updateBotStatus(result.bot_valid, result.bot_info);
            
        } catch (error) {
            this.showAlert('Âä†ËΩΩÈÖçÁΩÆÂ§±Ë¥•: ' + error.message, 'danger');
        }
    }
    
    async saveConfig(e) {
        e.preventDefault();
        
        const configData = {
            TELEGRAM_BOT_TOKEN: document.getElementById('bot-token').value.trim(),
            TELEGRAM_USER_ID: document.getElementById('user-id').value.trim(),
            PACK_NAME_PREFIX: document.getElementById('pack-prefix').value.trim(),
            DEFAULT_EMOJI: document.getElementById('default-emoji-config').value.trim() || 'üòÄ',
            ...this.getProxyConfig()
        };
        
        // È™åËØÅ‰ª£ÁêÜÈÖçÁΩÆ
        if (!this.validateProxyConfig(configData)) {
            return;
        }
        
        try {
            this.showLoading(true);
            const response = await fetch('/api/config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(configData)
            });
            
            const result = await response.json();
            
            if (result.success) {
                this.config = configData;
                this.updateBotStatus(true, result.bot_info);
                this.showAlert('ÈÖçÁΩÆ‰øùÂ≠òÊàêÂäü!', 'success');
            } else {
                this.showAlert('‰øùÂ≠òÂ§±Ë¥•: ' + result.error, 'danger');
            }
        } catch (error) {
            this.showAlert('‰øùÂ≠òÂ§±Ë¥•: ' + error.message, 'danger');
        } finally {
            this.showLoading(false);
        }
    }
    
    async testConfig() {
        const botToken = document.getElementById('bot-token').value.trim();
        
        if (!botToken) {
            this.showAlert('ËØ∑ÂÖàËæìÂÖ• Bot Token', 'warning');
            return;
        }
        
        try {
            this.showLoading(true);
            const response = await fetch('/api/config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    TELEGRAM_BOT_TOKEN: botToken,
                    TELEGRAM_USER_ID: document.getElementById('user-id').value.trim() || '0',
                    PACK_NAME_PREFIX: '',
                    DEFAULT_EMOJI: 'üòÄ'
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                this.showAlert(`ËøûÊé•ÊàêÂäü! Bot: @${result.bot_info.username}`, 'success');
                this.updateBotStatus(true, result.bot_info);
            } else {
                this.showAlert('ËøûÊé•Â§±Ë¥•: ' + result.error, 'danger');
                this.updateBotStatus(false);
            }
        } catch (error) {
            this.showAlert('ÊµãËØïÂ§±Ë¥•: ' + error.message, 'danger');
            this.updateBotStatus(false);
        } finally {
            this.showLoading(false);
        }
    }
    
    updateBotStatus(isValid, botInfo = null) {
        const statusIcon = document.getElementById('bot-status').querySelector('i');
        const infoText = document.getElementById('bot-info');
        const configWarning = document.getElementById('config-warning');
        
        if (isValid && botInfo) {
            statusIcon.className = 'bi bi-circle-fill text-success';
            infoText.textContent = `Â∑≤ËøûÊé•: @${botInfo.username}`;
            // ÈöêËóèÈÖçÁΩÆË≠¶Âëä
            if (configWarning) {
                configWarning.classList.add('d-none');
            }
        } else {
            statusIcon.className = 'bi bi-circle-fill text-danger';
            infoText.textContent = 'Êú™ÈÖçÁΩÆÊàñËøûÊé•Â§±Ë¥•';
            // ÊòæÁ§∫ÈÖçÁΩÆË≠¶Âëä
            if (configWarning) {
                configWarning.classList.remove('d-none');
            }
        }
    }
    
    // Ë°®ÊÉÖÂåÖÂàõÂª∫
    async createStickerPack(e) {
        e.preventDefault();
        
        if (this.uploadedFiles.length === 0) {
            this.showAlert('ËØ∑ÂÖà‰∏ä‰º†Êñá‰ª∂', 'warning');
            return;
        }
        
        if (!this.config.TELEGRAM_BOT_TOKEN || !this.config.TELEGRAM_USER_ID) {
            this.showAlert('ËØ∑ÂÖàÈÖçÁΩÆ Bot Token ÂíåÁî®Êà∑ ID', 'warning');
            this.switchTab('config');
            return;
        }
        
        const packData = {
            pack_name: document.getElementById('pack-name').value.trim(),
            pack_title: document.getElementById('pack-title').value.trim(),
            files: this.uploadedFiles,
            emojis: this.getEmojiList()
        };
        
        try {
            this.showLoading(true);
            const response = await fetch('/api/create-sticker-pack', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(packData)
            });
            
            const result = await response.json();
            
            if (result.success) {
                this.currentTask = result.task_id;
                this.showProgressCard(true);
                this.pollTaskStatus();
            } else {
                this.showAlert('ÂàõÂª∫Â§±Ë¥•: ' + result.error, 'danger');
            }
        } catch (error) {
            this.showAlert('ÂàõÂª∫Â§±Ë¥•: ' + error.message, 'danger');
        } finally {
            this.showLoading(false);
        }
    }
    
    getEmojiList() {
        const defaultEmoji = document.getElementById('default-emoji').value.trim() || 'üòÄ';
        return this.uploadedFiles.map(() => defaultEmoji);
    }
    
    showProgressCard(show) {
        const card = document.getElementById('progress-card');
        card.style.display = show ? 'block' : 'none';
        
        if (!show) {
            this.resetProgress();
        }
    }
    
    resetProgress() {
        document.getElementById('progress-bar').style.width = '0%';
        document.getElementById('progress-text').textContent = 'Á≠âÂæÖÂºÄÂßã...';
    }
    
    async pollTaskStatus() {
        if (!this.currentTask) return;
        
        try {
            const response = await fetch(`/api/task-status/${this.currentTask}`);
            const status = await response.json();
            
            this.updateProgress(status);
            
            if (status.status === 'processing' || status.status === 'starting') {
                setTimeout(() => this.pollTaskStatus(), 1000);
            } else if (status.status === 'completed') {
                this.handleTaskCompleted(status);
            } else if (status.status === 'error') {
                this.handleTaskError(status);
            }
        } catch (error) {
            this.showAlert('Ëé∑ÂèñËøõÂ∫¶Â§±Ë¥•: ' + error.message, 'danger');
        }
    }
    
    updateProgress(status) {
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        
        progressBar.style.width = `${status.progress}%`;
        progressText.textContent = `${status.message} (${Math.round(status.progress)}%)`;
    }
    
    handleTaskCompleted(status) {
        this.showAlert('Ë°®ÊÉÖÂåÖÂàõÂª∫ÊàêÂäü!', 'success');
        this.updateProgress({progress: 100, message: 'ÂÆåÊàê!'});
        
        if (status.result && status.result.pack_url) {
            this.showAlert(`Ë°®ÊÉÖÂåÖÈìæÊé•: <a href="${status.result.pack_url}" target="_blank">${status.result.pack_url}</a>`, 'info');
        }
        
        setTimeout(() => {
            this.showProgressCard(false);
            this.resetForm();
        }, 3000);
    }
    
    handleTaskError(status) {
        this.showAlert('ÂàõÂª∫Â§±Ë¥•: ' + status.message, 'danger');
        this.showProgressCard(false);
    }
    
    resetForm() {
        document.getElementById('sticker-form').reset();
        document.getElementById('default-emoji').value = this.config.DEFAULT_EMOJI || 'üòÄ';
        this.uploadedFiles = [];
        this.displayUploadedFiles();
        this.updateCreateButton();
    }
    
    // Ë°®ÊÉÖÂåÖÁÆ°ÁêÜ
    async searchStickerPack() {
        const packName = document.getElementById('pack-search').value.trim();
        
        if (!packName) {
            this.showAlert('ËØ∑ËæìÂÖ•Ë°®ÊÉÖÂåÖÂêçÁß∞', 'warning');
            return;
        }
        
        if (!this.config.TELEGRAM_BOT_TOKEN) {
            this.showAlert('ËØ∑ÂÖàÈÖçÁΩÆ Bot Token', 'warning');
            this.switchTab('config');
            return;
        }
        
        try {
            this.showLoading(true);
            const response = await fetch(`/api/sticker-pack/${encodeURIComponent(packName)}`);
            const result = await response.json();
            
            if (result.success) {
                this.displayStickerPack(result.pack);
            } else {
                this.showAlert('Êâæ‰∏çÂà∞Ë°®ÊÉÖÂåÖ: ' + result.error, 'warning');
                this.hideStickerPack();
            }
        } catch (error) {
            this.showAlert('ÊêúÁ¥¢Â§±Ë¥•: ' + error.message, 'danger');
            this.hideStickerPack();
        } finally {
            this.showLoading(false);
        }
    }
    
    displayStickerPack(pack) {
        document.getElementById('pack-placeholder').style.display = 'none';
        document.getElementById('pack-info').style.display = 'block';
        
        const packInfo = document.getElementById('pack-info');
        packInfo.innerHTML = `
            <div class="d-flex justify-content-between align-items-center mb-4">
                <div>
                    <h4>${pack.title}</h4>
                    <p class="text-muted mb-0">
                        ${pack.name} ‚Ä¢ ${pack.total_stickers} ‰∏™Ë¥¥Á∫∏ ‚Ä¢ 
                        ${pack.is_animated ? 'Âä®Áîª' : pack.is_video ? 'ËßÜÈ¢ë' : 'ÈùôÊÄÅ'}
                    </p>
                </div>
                <div>
                    <button class="btn btn-danger btn-sm" onclick="stickerMaker.deleteStickerPack('${pack.name}')">
                        <i class="bi bi-trash"></i> Âà†Èô§Ë°®ÊÉÖÂåÖ
                    </button>
                </div>
            </div>
            
            <div class="row">
                ${pack.stickers.map(sticker => `
                    <div class="col-md-6 col-lg-4 mb-3">
                        <div class="sticker-item">
                            <div class="d-flex align-items-center">
                                <div class="sticker-emoji me-3">
                                    ${sticker.emoji}
                                </div>
                                <div class="flex-grow-1">
                                    <div class="d-flex justify-content-between align-items-center">
                                        <small class="text-muted">‰ΩçÁΩÆ ${sticker.position}</small>
                                        <div>
                                            <button class="btn btn-sm btn-outline-primary me-1" 
                                                    onclick="stickerMaker.editSticker('${pack.name}', '${sticker.file_id}', '${sticker.emoji}')">
                                                <i class="bi bi-pencil"></i>
                                            </button>
                                            <button class="btn btn-sm btn-outline-danger" 
                                                    onclick="stickerMaker.deleteSticker('${pack.name}', '${sticker.file_id}')">
                                                <i class="bi bi-trash"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <small class="text-muted d-block">${sticker.width}√ó${sticker.height}px</small>
                                    <small class="text-muted">${sticker.file_id.substring(0, 20)}...</small>
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    hideStickerPack() {
        document.getElementById('pack-placeholder').style.display = 'block';
        document.getElementById('pack-info').style.display = 'none';
    }
    
    editSticker(packName, fileId, currentEmoji) {
        document.getElementById('edit-pack-name').value = packName;
        document.getElementById('edit-file-id').value = fileId;
        document.getElementById('edit-emoji-list').value = currentEmoji;
        
        const modal = new bootstrap.Modal(document.getElementById('editStickerModal'));
        modal.show();
    }
    
    async saveStickerEdit() {
        const packName = document.getElementById('edit-pack-name').value;
        const fileId = document.getElementById('edit-file-id').value;
        const emojiList = document.getElementById('edit-emoji-list').value.split(',').map(e => e.trim()).filter(e => e);
        
        if (emojiList.length === 0) {
            this.showAlert('ËØ∑ËæìÂÖ•Ëá≥Â∞ë‰∏Ä‰∏™ emoji', 'warning');
            return;
        }
        
        try {
            this.showLoading(true);
            const response = await fetch(`/api/sticker-pack/${encodeURIComponent(packName)}/sticker/${encodeURIComponent(fileId)}/emoji`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({emoji_list: emojiList})
            });
            
            const result = await response.json();
            
            if (result.success) {
                this.showAlert('Êõ¥Êñ∞ÊàêÂäü!', 'success');
                const modal = bootstrap.Modal.getInstance(document.getElementById('editStickerModal'));
                modal.hide();
                
                // ÈáçÊñ∞Âä†ËΩΩË°®ÊÉÖÂåÖ‰ø°ÊÅØ
                setTimeout(() => this.searchStickerPack(), 500);
            } else {
                this.showAlert('Êõ¥Êñ∞Â§±Ë¥•: ' + result.error, 'danger');
            }
        } catch (error) {
            this.showAlert('Êõ¥Êñ∞Â§±Ë¥•: ' + error.message, 'danger');
        } finally {
            this.showLoading(false);
        }
    }
    
    async deleteSticker(packName, fileId) {
        if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™Ë¥¥Á∫∏ÂêóÔºü')) {
            return;
        }
        
        try {
            this.showLoading(true);
            const response = await fetch(`/api/sticker-pack/${encodeURIComponent(packName)}/sticker/${encodeURIComponent(fileId)}`, {
                method: 'DELETE'
            });
            
            const result = await response.json();
            
            if (result.success) {
                this.showAlert('Âà†Èô§ÊàêÂäü!', 'success');
                // ÈáçÊñ∞Âä†ËΩΩË°®ÊÉÖÂåÖ‰ø°ÊÅØ
                setTimeout(() => this.searchStickerPack(), 500);
            } else {
                this.showAlert('Âà†Èô§Â§±Ë¥•: ' + result.error, 'danger');
            }
        } catch (error) {
            this.showAlert('Âà†Èô§Â§±Ë¥•: ' + error.message, 'danger');
        } finally {
            this.showLoading(false);
        }
    }
    
    async deleteStickerPack(packName) {
        if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Êï¥‰∏™Ë°®ÊÉÖÂåÖÂêóÔºüÊ≠§Êìç‰ΩúÊó†Ê≥ïÊí§ÈîÄÔºÅ')) {
            return;
        }
        
        const confirmText = prompt('ËØ∑ËæìÂÖ• "DELETE" Á°ÆËÆ§Âà†Èô§:');
        if (confirmText !== 'DELETE') {
            this.showAlert('Â∑≤ÂèñÊ∂àÂà†Èô§', 'info');
            return;
        }
        
        try {
            this.showLoading(true);
            const response = await fetch(`/api/sticker-pack/${encodeURIComponent(packName)}`, {
                method: 'DELETE'
            });
            
            const result = await response.json();
            
            if (result.success) {
                this.showAlert('Ë°®ÊÉÖÂåÖÂà†Èô§ÊàêÂäü!', 'success');
                this.hideStickerPack();
                document.getElementById('pack-search').value = '';
            } else {
                this.showAlert('Âà†Èô§Â§±Ë¥•: ' + result.error, 'danger');
            }
        } catch (error) {
            this.showAlert('Âà†Èô§Â§±Ë¥•: ' + error.message, 'danger');
        } finally {
            this.showLoading(false);
        }
    }
    
    // ‰ª£ÁêÜËÆæÁΩÆÁõ∏ÂÖ≥ÊñπÊ≥ï
    toggleProxySettings(e) {
        const proxySettings = document.getElementById('proxy-settings');
        proxySettings.style.display = e.target.checked ? 'block' : 'none';
    }
    
    toggleProxyAuth(e) {
        const proxyAuthSettings = document.getElementById('proxy-auth-settings');
        proxyAuthSettings.style.display = e.target.checked ? 'block' : 'none';
    }
    
    loadProxyConfig(config) {
        // Âä†ËΩΩ‰ª£ÁêÜÈÖçÁΩÆÂà∞Ë°®Âçï
        const proxyEnabled = config.PROXY_ENABLED === 'true';
        document.getElementById('proxy-enabled').checked = proxyEnabled;
        
        if (proxyEnabled) {
            document.getElementById('proxy-settings').style.display = 'block';
            document.getElementById('proxy-type').value = config.PROXY_TYPE || 'http';
            document.getElementById('proxy-host').value = config.PROXY_HOST || '';
            document.getElementById('proxy-port').value = config.PROXY_PORT || '';
            
            const authEnabled = config.PROXY_AUTH_ENABLED === 'true';
            document.getElementById('proxy-auth-enabled').checked = authEnabled;
            
            if (authEnabled) {
                document.getElementById('proxy-auth-settings').style.display = 'block';
                document.getElementById('proxy-username').value = config.PROXY_USERNAME || '';
                document.getElementById('proxy-password').value = config.PROXY_PASSWORD || '';
            }
        }
    }
    
    getProxyConfig() {
        const proxyEnabled = document.getElementById('proxy-enabled').checked;
        
        if (!proxyEnabled) {
            return {
                PROXY_ENABLED: 'false'
            };
        }
        
        const authEnabled = document.getElementById('proxy-auth-enabled').checked;
        
        const proxyConfig = {
            PROXY_ENABLED: 'true',
            PROXY_TYPE: document.getElementById('proxy-type').value,
            PROXY_HOST: document.getElementById('proxy-host').value.trim(),
            PROXY_PORT: document.getElementById('proxy-port').value.trim(),
            PROXY_AUTH_ENABLED: authEnabled ? 'true' : 'false'
        };
        
        if (authEnabled) {
            proxyConfig.PROXY_USERNAME = document.getElementById('proxy-username').value.trim();
            proxyConfig.PROXY_PASSWORD = document.getElementById('proxy-password').value.trim();
        }
        
        return proxyConfig;
    }
    
    validateProxyConfig(proxyConfig) {
        if (proxyConfig.PROXY_ENABLED === 'true') {
            if (!proxyConfig.PROXY_HOST) {
                this.showAlert('‰ª£ÁêÜÊúçÂä°Âô®Âú∞ÂùÄ‰∏çËÉΩ‰∏∫Á©∫', 'warning');
                return false;
            }
            
            if (!proxyConfig.PROXY_PORT || isNaN(proxyConfig.PROXY_PORT)) {
                this.showAlert('‰ª£ÁêÜÁ´ØÂè£ÂøÖÈ°ªÊòØÊúâÊïàÊï∞Â≠ó', 'warning');
                return false;
            }
            
            const port = parseInt(proxyConfig.PROXY_PORT);
            if (port < 1 || port > 65535) {
                this.showAlert('‰ª£ÁêÜÁ´ØÂè£ÂøÖÈ°ªÂú®1-65535‰πãÈó¥', 'warning');
                return false;
            }
            
            if (proxyConfig.PROXY_AUTH_ENABLED === 'true') {
                if (!proxyConfig.PROXY_USERNAME) {
                    this.showAlert('ÂêØÁî®ËÆ§ËØÅÊó∂Áî®Êà∑Âêç‰∏çËÉΩ‰∏∫Á©∫', 'warning');
                    return false;
                }
                
                if (!proxyConfig.PROXY_PASSWORD) {
                    this.showAlert('ÂêØÁî®ËÆ§ËØÅÊó∂ÂØÜÁ†Å‰∏çËÉΩ‰∏∫Á©∫', 'warning');
                    return false;
                }
            }
        }
        
        return true;
    }
    
    // ÈÄöÁî®Â∑•ÂÖ∑ÊñπÊ≥ï
    showAlert(message, type = 'info') {
        const alertContainer = document.getElementById('alert-container');
        const alert = document.createElement('div');
        alert.className = `alert alert-${type} alert-dismissible fade show`;
        alert.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        
        alertContainer.appendChild(alert);
        
        // Ëá™Âä®ÂÖ≥Èó≠
        setTimeout(() => {
            if (alert.parentNode) {
                alert.classList.add('fade-out');
                setTimeout(() => alert.remove(), 300);
            }
        }, 5000);
    }
    
    showLoading(show) {
        // ÁÆÄÂçïÁöÑÂä†ËΩΩÁä∂ÊÄÅÔºåÂèØ‰ª•Êâ©Â±ï‰∏∫ÂÖ®Â±ÄÂä†ËΩΩÈÅÆÁΩ©
        document.body.style.cursor = show ? 'wait' : 'default';
    }
}

// ÂÖ®Â±ÄÂèòÈáèÂíåÂáΩÊï∞
let stickerMaker;

// ÂÖ®Â±ÄswitchTabÂáΩÊï∞Ôºå‰æõHTMLË∞ÉÁî®
function switchTab(tabName) {
    if (stickerMaker) {
        stickerMaker.switchTab(tabName);
    }
}

// È°µÈù¢Âä†ËΩΩÂÆåÊàêÂêéÂàùÂßãÂåñ
document.addEventListener('DOMContentLoaded', () => {
    stickerMaker = new StickerMaker();
});