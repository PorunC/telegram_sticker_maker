#!/usr/bin/env python3
"""
Telegram Sticker Maker - Áªü‰∏ÄË°®ÊÉÖÂåÖÂà∂‰ΩúÂíåÂØºÂÖ•Â∑•ÂÖ∑

Ëá™Âä®ÈÄâÊã©ÊúÄ‰Ω≥Ê†ºÂºèÂπ∂ÂØºÂÖ•Âà∞Telegram:
- ÈùôÊÄÅÂõæÁâá ‚Üí PNG/WebP (‚â§512KB)
- Âä®Áîª/ËßÜÈ¢ë ‚Üí WebM (‚â§256KB)

ÊîØÊåÅTelegram 7.8+ÂØºÂÖ•API
"""

import os
import sys
import json
import time
import logging
import tempfile
import subprocess
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass
from PIL import Image, ImageSequence
import urllib.parse
import webbrowser

@dataclass
class StickerConfig:
    """Ë°®ÊÉÖÂåÖÈÖçÁΩÆ"""
    # ËæìÂÖ•‰ø°ÊÅØ
    input_path: str = ""
    output_dir: str = "output"
    
    # Ë°®ÊÉÖÂåÖÂÖÉÊï∞ÊçÆ
    pack_name: str = "MyCustomStickers"
    emojis: List[str] = None
    
    # Ê†ºÂºèÈôêÂà∂
    static_max_size_kb: int = 512
    webm_max_size_kb: int = 256
    
    # Â∞∫ÂØ∏Ë¶ÅÊ±Ç
    max_dimension: int = 512
    
    # Ëá™Âä®ÈÄâÊã©Á≠ñÁï•
    auto_format: bool = True
    preferred_format: str = "auto"  # "auto", "static", "webm"
    
    # Telegram API Ëá™Âä®‰∏ä‰º†
    auto_upload: bool = False
    bot_token: str = ""
    user_id: int = 0
    
    def __post_init__(self):
        if self.emojis is None:
            self.emojis = ["üòÄ"]  # ÈªòËÆ§emoji


def load_env_file(env_path: str = ".env") -> Dict[str, str]:
    """Âä†ËΩΩ .env Êñá‰ª∂"""
    env_vars = {}
    if os.path.exists(env_path):
        try:
            with open(env_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        if '=' in line:
                            key, value = line.split('=', 1)
                            env_vars[key.strip()] = value.strip()
        except Exception as e:
            print(f"‚ö†Ô∏è ËØªÂèñ .env Êñá‰ª∂Â§±Ë¥•: {e}")
    return env_vars


class TelegramStickerMaker:
    """TelegramË°®ÊÉÖÂåÖÂà∂‰ΩúÂô®"""
    
    def __init__(self, config: StickerConfig = None):
        self.config = config or StickerConfig()
        self.logger = self._setup_logger()
        self.temp_dir = tempfile.mkdtemp()
        
        # ÂØºÂÖ•WebMËΩ¨Êç¢Âô®
        self._load_webm_converter()
        
        # ÂØºÂÖ•Telegram API‰∏ä‰º†Âô®
        self._load_telegram_uploader()
    
    def _setup_logger(self) -> logging.Logger:
        """ËÆæÁΩÆÊó•Âøó"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        return logging.getLogger(__name__)
    
    def _load_webm_converter(self):
        """Âä†ËΩΩWebMËΩ¨Êç¢Âô®"""
        try:
            sys.path.insert(0, os.path.dirname(__file__))
            from telegram_webm_converter import TelegramWebMConverter, TelegramWebMConfig
            self.webm_converter = TelegramWebMConverter
            self.webm_config = TelegramWebMConfig
            self.logger.info("‚úì WebM converter loaded")
        except Exception as e:
            self.logger.error(f"Failed to load WebM converter: {e}")
            raise
    
    def _load_telegram_uploader(self):
        """Âä†ËΩΩTelegram API‰∏ä‰º†Âô®"""
        try:
            from telegram_api_uploader import TelegramStickerUploader
            self.telegram_uploader_class = TelegramStickerUploader
            self.logger.info("‚úì Telegram API uploader loaded")
        except Exception as e:
            self.logger.warning(f"Telegram API uploader not available: {e}")
            self.telegram_uploader_class = None
    
    def analyze_input(self, input_path: str) -> Dict[str, Any]:
        """ÂàÜÊûêËæìÂÖ•Êñá‰ª∂ÁâπÂæÅ"""
        if not os.path.exists(input_path):
            raise FileNotFoundError(f"Input file not found: {input_path}")
        
        file_size = os.path.getsize(input_path)
        file_ext = Path(input_path).suffix.lower()
        
        analysis = {
            'path': input_path,
            'size_bytes': file_size,
            'size_kb': file_size / 1024,
            'extension': file_ext,
            'is_animated': False,
            'is_video': False,
            'dimensions': (0, 0),
            'frame_count': 1,
            'duration': 0.0,
            'complexity_score': 0,
            'recommended_format': 'static'
        }
        
        try:
            if file_ext in ['.gif', '.webp', '.png', '.jpg', '.jpeg']:
                # ÂõæÁâáÊñá‰ª∂ÂàÜÊûê
                with Image.open(input_path) as img:
                    analysis['dimensions'] = img.size
                    analysis['is_animated'] = getattr(img, 'is_animated', False)
                    
                    if analysis['is_animated']:
                        analysis['frame_count'] = getattr(img, 'n_frames', 1)
                        
                        # ËÆ°ÁÆóÊÄªÊó∂Èïø
                        durations = []
                        for frame in ImageSequence.Iterator(img):
                            duration = frame.info.get('duration', 100)
                            durations.append(duration)
                        
                        analysis['duration'] = sum(durations) / 1000.0  # ËΩ¨Êç¢‰∏∫Áßí
                        
                        # Â§çÊùÇÂ∫¶ËØÑÂàÜÔºàÂü∫‰∫éÂ∏ßÊï∞„ÄÅÂ∞∫ÂØ∏„ÄÅÊó∂ÈïøÔºâ
                        complexity = (
                            analysis['frame_count'] * 0.1 +
                            (analysis['dimensions'][0] * analysis['dimensions'][1]) / 10000 +
                            analysis['duration'] * 2
                        )
                        analysis['complexity_score'] = complexity
            
            elif file_ext in ['.mp4', '.avi', '.mov', '.webm']:
                # ËßÜÈ¢ëÊñá‰ª∂ÂàÜÊûê
                analysis['is_video'] = True
                analysis['is_animated'] = True
                
                # ‰ΩøÁî®ffprobeÂàÜÊûêËßÜÈ¢ë
                try:
                    cmd = [
                        'ffprobe', '-v', 'quiet', '-print_format', 'json',
                        '-show_format', '-show_streams', input_path
                    ]
                    result = subprocess.run(cmd, capture_output=True, text=True)
                    if result.returncode == 0:
                        data = json.loads(result.stdout)
                        
                        video_stream = next(
                            (s for s in data['streams'] if s['codec_type'] == 'video'),
                            None
                        )
                        
                        if video_stream:
                            analysis['dimensions'] = (
                                video_stream.get('width', 0),
                                video_stream.get('height', 0)
                            )
                        
                        if 'format' in data:
                            analysis['duration'] = float(data['format'].get('duration', 0))
                        
                        # ËßÜÈ¢ëÂ§çÊùÇÂ∫¶Êõ¥È´ò
                        analysis['complexity_score'] = 50 + analysis['duration'] * 10
                
                except Exception as e:
                    self.logger.warning(f"Video analysis failed: {e}")
        
        except Exception as e:
            self.logger.warning(f"File analysis failed: {e}")
        
        # Êé®ËçêÊ†ºÂºè
        analysis['recommended_format'] = self._recommend_format(analysis)
        
        return analysis
    
    def _recommend_format(self, analysis: Dict[str, Any]) -> str:
        """Ê†πÊçÆÂàÜÊûêÁªìÊûúÊé®ËçêÊúÄ‰Ω≥Ê†ºÂºè"""
        if not analysis['is_animated']:
            return 'static'
        else:
            # ÊâÄÊúâÂä®ÁîªÈÉΩ‰ΩøÁî®WebM
            return 'webm'
    
    def create_static_sticker(self, input_path: str, output_path: str) -> Dict[str, Any]:
        """ÂàõÂª∫ÈùôÊÄÅPNGË°®ÊÉÖÂåÖ"""
        result = {
            'success': False,
            'format': 'static',
            'output_path': output_path,
            'file_size': 0,
            'message': ''
        }
        
        try:
            with Image.open(input_path) as img:
                # ËΩ¨Êç¢‰∏∫RGBAÔºàÊîØÊåÅÈÄèÊòéÔºâ
                if img.mode != 'RGBA':
                    img = img.convert('RGBA')
                
                # ËÆ°ÁÆóÁº©ÊîæÂ∞∫ÂØ∏
                width, height = img.size
                if width > self.config.max_dimension or height > self.config.max_dimension:
                    # ÈúÄË¶ÅÁº©Êîæ
                    if width >= height:
                        new_width = self.config.max_dimension
                        new_height = int(height * (self.config.max_dimension / width))
                    else:
                        new_height = self.config.max_dimension
                        new_width = int(width * (self.config.max_dimension / height))
                    
                    img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
                
                # Á°Æ‰øùËæìÂá∫ÁõÆÂΩïÂ≠òÂú®
                os.makedirs(os.path.dirname(output_path), exist_ok=True)
                
                # ‰øùÂ≠ò‰∏∫PNG
                img.save(output_path, 'PNG', optimize=True)
                
                file_size = os.path.getsize(output_path)
                
                # Ê£ÄÊü•Â§ßÂ∞èÈôêÂà∂
                max_size = self.config.static_max_size_kb * 1024
                if file_size > max_size:
                    # Â∞ùËØïÂéãÁº©
                    quality = 95
                    while file_size > max_size and quality > 10:
                        # ËΩ¨Êç¢‰∏∫WebPÊ†ºÂºèÂéãÁº©
                        webp_path = output_path.replace('.png', '.webp')
                        img.save(webp_path, 'WEBP', quality=quality, method=6)
                        
                        file_size = os.path.getsize(webp_path)
                        if file_size <= max_size:
                            os.remove(output_path)
                            os.rename(webp_path, output_path.replace('.png', '.webp'))
                            result['output_path'] = output_path.replace('.png', '.webp')
                            break
                        
                        quality -= 10
                        if os.path.exists(webp_path):
                            os.remove(webp_path)
                
                result['file_size'] = os.path.getsize(result['output_path'])
                result['success'] = result['file_size'] <= max_size
                result['message'] = f"Static sticker created: {result['file_size']/1024:.1f}KB"
                
        except Exception as e:
            result['message'] = f"Failed to create static sticker: {e}"
            self.logger.error(result['message'])
        
        return result
    
    
    def create_webm_sticker(self, input_path: str, output_path: str) -> Dict[str, Any]:
        """ÂàõÂª∫WebMËßÜÈ¢ëË°®ÊÉÖÂåÖ"""
        result = {
            'success': False,
            'format': 'webm',
            'output_path': output_path,
            'file_size': 0,
            'message': ''
        }
        
        try:
            # ‰ΩøÁî®WebMËΩ¨Êç¢Âô®
            webm_config = self.webm_config(
                output_type="sticker",
                max_file_size_kb=self.config.webm_max_size_kb
            )
            converter = self.webm_converter(webm_config)
            
            conversion_result = converter.convert_gif_to_webm(input_path, output_path)
            
            result['success'] = conversion_result['success']
            result['file_size'] = conversion_result.get('file_size_after', 0)
            result['message'] = conversion_result['message']
            
        except Exception as e:
            result['message'] = f"Failed to create WebM sticker: {e}"
            self.logger.error(result['message'])
        
        return result
    
    def create_sticker_pack(self, input_files: List[str], pack_name: str = None) -> Dict[str, Any]:
        """ÂàõÂª∫ÂÆåÊï¥ÁöÑË°®ÊÉÖÂåÖ"""
        pack_name = pack_name or self.config.pack_name
        output_dir = os.path.join(self.config.output_dir, pack_name)
        os.makedirs(output_dir, exist_ok=True)
        
        results = {
            'pack_name': pack_name,
            'output_dir': output_dir,
            'stickers': [],
            'total_files': len(input_files),
            'successful': 0,
            'failed': 0
        }
        
        for i, input_file in enumerate(input_files):
            self.logger.info(f"Processing {i+1}/{len(input_files)}: {input_file}")
            
            # ÂàÜÊûêËæìÂÖ•Êñá‰ª∂
            try:
                analysis = self.analyze_input(input_file)
                self.logger.info(f"Recommended format: {analysis['recommended_format']}")
                
                # ÈÄâÊã©Ê†ºÂºè
                format_choice = analysis['recommended_format']
                if not self.config.auto_format:
                    format_choice = self.config.preferred_format
                
                # ÁîüÊàêËæìÂá∫Êñá‰ª∂Âêç
                base_name = Path(input_file).stem
                
                sticker_result = None
                
                if format_choice == 'static':
                    output_path = os.path.join(output_dir, f"{base_name}.png")
                    sticker_result = self.create_static_sticker(input_file, output_path)
                elif format_choice == 'webm':
                    output_path = os.path.join(output_dir, f"{base_name}.webm")
                    sticker_result = self.create_webm_sticker(input_file, output_path)
                
                if sticker_result and sticker_result['success']:
                    results['successful'] += 1
                    sticker_result['input_file'] = input_file
                    sticker_result['analysis'] = analysis
                    results['stickers'].append(sticker_result)
                else:
                    results['failed'] += 1
                    self.logger.error(f"Failed to process {input_file}")
                    
            except Exception as e:
                results['failed'] += 1
                self.logger.error(f"Error processing {input_file}: {e}")
        
        # ÁîüÊàêË°®ÊÉÖÂåÖÂÖÉÊï∞ÊçÆ
        self._generate_pack_metadata(results)
        
        return results
    
    def _generate_pack_metadata(self, results: Dict[str, Any]):
        """ÁîüÊàêË°®ÊÉÖÂåÖÂÖÉÊï∞ÊçÆ"""
        metadata = {
            'pack_name': results['pack_name'],
            'created_at': time.time(),
            'total_stickers': results['successful'],
            'formats_used': {},
            'stickers': []
        }
        
        for sticker in results['stickers']:
            fmt = sticker['format']
            if fmt not in metadata['formats_used']:
                metadata['formats_used'][fmt] = 0
            metadata['formats_used'][fmt] += 1
            
            metadata['stickers'].append({
                'file': os.path.basename(sticker['output_path']),
                'format': fmt,
                'size_kb': sticker['file_size'] / 1024,
                'emoji': self.config.emojis[0] if self.config.emojis else "üòÄ"
            })
        
        # ‰øùÂ≠òÂÖÉÊï∞ÊçÆ
        metadata_path = os.path.join(results['output_dir'], 'pack_info.json')
        with open(metadata_path, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)
        
        self.logger.info(f"Pack metadata saved to {metadata_path}")
    
    def upload_to_telegram(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Ëá™Âä®‰∏ä‰º†Ë°®ÊÉÖÂåÖÂà∞Telegram"""
        upload_result = {
            'success': False,
            'pack_url': '',
            'message': '',
            'uploaded_count': 0,
            'failed_count': 0
        }
        
        if not self.config.auto_upload:
            upload_result['message'] = 'Auto upload disabled'
            return upload_result
        
        if not self.telegram_uploader_class:
            upload_result['message'] = 'Telegram API uploader not available'
            return upload_result
        
        if not self.config.bot_token:
            upload_result['message'] = 'Bot token not provided'
            return upload_result
        
        if not self.config.user_id:
            upload_result['message'] = 'User ID not provided'
            return upload_result
        
        if not results['stickers']:
            upload_result['message'] = 'No stickers to upload'
            return upload_result
        
        try:
            # ÂàõÂª∫‰∏ä‰º†Âô®ÂÆû‰æã
            uploader = self.telegram_uploader_class(self.config.bot_token)
            
            # Êî∂ÈõÜË°®ÊÉÖÂåÖÊñá‰ª∂
            sticker_files = [sticker['output_path'] for sticker in results['stickers']]
            emojis = [self.config.emojis[0] if self.config.emojis else "üòÄ"] * len(sticker_files)
            
            # ÁîüÊàêË°®ÊÉÖÂåÖÂêçÁß∞
            pack_name = uploader.generate_pack_name(results['pack_name'], self.config.user_id)
            pack_title = f"{results['pack_name']} Stickers"
            
            self.logger.info(f"üöÄ Uploading sticker pack to Telegram...")
            
            # ‰∏ä‰º†Ë°®ÊÉÖÂåÖ
            api_result = uploader.upload_sticker_pack(
                user_id=self.config.user_id,
                pack_name=pack_name,
                pack_title=pack_title,
                sticker_files=sticker_files,
                emojis=emojis
            )
            
            upload_result['success'] = api_result['success']
            upload_result['pack_url'] = api_result['pack_url']
            upload_result['uploaded_count'] = api_result['uploaded_count']
            upload_result['failed_count'] = api_result['failed_count']
            
            if api_result['success']:
                upload_result['message'] = f"Successfully uploaded {api_result['uploaded_count']} stickers"
            else:
                upload_result['message'] = f"Upload failed: {'; '.join(api_result['errors'])}"
            
        except Exception as e:
            upload_result['message'] = f"Upload error: {e}"
            self.logger.error(f"Upload error: {e}")
        
        return upload_result
    
    def generate_telegram_import_url(self, pack_dir: str) -> str:
        """ÁîüÊàêTelegramÂØºÂÖ•URL"""
        # ËøôÈáåÂ∫îËØ•ÂÆûÁé∞ÁúüÊ≠£ÁöÑTelegramÂØºÂÖ•APIÈõÜÊàê
        # ÁõÆÂâçÁîüÊàê‰∏Ä‰∏™ÊåáÂêë@stickersÊú∫Âô®‰∫∫ÁöÑURL
        
        pack_name = os.path.basename(pack_dir)
        encoded_name = urllib.parse.quote(pack_name)
        
        # TelegramÂØºÂÖ•URLÊ†ºÂºèÔºàËøôÊòØ‰∏Ä‰∏™ÁÆÄÂåñÁöÑÂÆûÁé∞Ôºâ
        base_url = "https://t.me/stickers"
        import_url = f"{base_url}?start=import_{encoded_name}"
        
        return import_url
    
    def open_telegram_import(self, pack_dir: str):
        """ÊâìÂºÄTelegramÂØºÂÖ•È°µÈù¢"""
        import_url = self.generate_telegram_import_url(pack_dir)
        
        print(f"\nüéØ TelegramÂØºÂÖ•ÈìæÊé•:")
        print(f"üì± {import_url}")
        print(f"\nüìã ‰ΩøÁî®ËØ¥Êòé:")
        print(f"1. ÁÇπÂáª‰∏äÊñπÈìæÊé•ÊâìÂºÄTelegram")
        print(f"2. ‰∏é @stickers Êú∫Âô®‰∫∫ÂØπËØù")
        print(f"3. ‰ΩøÁî® /newpack ÂëΩ‰ª§ÂàõÂª∫Êñ∞Ë°®ÊÉÖÂåÖ")
        print(f"4. ‰∏ä‰º† {pack_dir} ÁõÆÂΩï‰∏≠ÁöÑÊñá‰ª∂")
        
        # Â∞ùËØïËá™Âä®ÊâìÂºÄÊµèËßàÂô®
        try:
            webbrowser.open(import_url)
        except:
            pass


def show_help():
    """ÊòæÁ§∫Â∏ÆÂä©‰ø°ÊÅØ"""
    print("üéØ Telegram Sticker Maker")
    print("Áªü‰∏ÄË°®ÊÉÖÂåÖÂà∂‰ΩúÂíåÂØºÂÖ•Â∑•ÂÖ∑")
    print()
    print("Áî®Ê≥ï:")
    print("  python telegram_sticker_maker.py <input_file_or_directory> [options]")
    print()
    print("ÈÄâÈ°π:")
    print("  --pack-name NAME     Ë°®ÊÉÖÂåÖÂêçÁß∞ (ÈªòËÆ§: MyCustomStickers)")
    print("  --format FORMAT      Âº∫Âà∂Ê†ºÂºè: static/webm/auto (ÈªòËÆ§: auto)")
    print("  --emoji EMOJI        ÈªòËÆ§emoji (ÈªòËÆ§: üòÄ)")
    print("  --output-dir DIR     ËæìÂá∫ÁõÆÂΩï (ÈªòËÆ§: output)")
    print("  --open-telegram      ÂÆåÊàêÂêéÊâìÂºÄTelegramÂØºÂÖ•")
    print("  --upload             Ëá™Âä®‰∏ä‰º†Âà∞Telegram (ÈúÄË¶ÅBot Token)")
    print("  --bot-token TOKEN    Telegram Bot Token")
    print("  --user-id ID         Telegram Áî®Êà∑ID")
    print("  --help, -h           ÊòæÁ§∫Ê≠§Â∏ÆÂä©‰ø°ÊÅØ")
    print()
    print("ÊîØÊåÅÊ†ºÂºè:")
    print("  üì• ËæìÂÖ•: GIF, PNG, WEBP, MP4, WebM")
    print("  üì§ ËæìÂá∫: PNG/WebP (ÈùôÊÄÅ), WebM (Âä®Áîª/ËßÜÈ¢ë)")
    print()
    print("Á§∫‰æã:")
    print("  python telegram_sticker_maker.py my_image.gif")
    print("  python telegram_sticker_maker.py ./images/ --pack-name MyPack")
    print("  python telegram_sticker_maker.py dance.gif --format webm --emoji üé¨")
    print("  python telegram_sticker_maker.py ./stickers/ --upload --bot-token TOKEN --user-id 123456")
    print()
    print("TelegramËá™Âä®‰∏ä‰º†:")
    print("  1. ‰∏é@BotFatherÂàõÂª∫BotËé∑ÂæóToken")
    print("  2. Ëé∑Âèñ‰Ω†ÁöÑTelegramÁî®Êà∑ID")
    print("  3. ÂàõÂª∫.envÊñá‰ª∂ÈÖçÁΩÆÊàñ‰ΩøÁî®ÂëΩ‰ª§Ë°åÂèÇÊï∞")
    print("  4. ‰ΩøÁî®--uploadÈÄâÈ°πËá™Âä®‰∏ä‰º†Ë°®ÊÉÖÂåÖ")
    print("  5. Ëé∑Âæót.me/addstickers/xxxÂàÜ‰∫´ÈìæÊé•")
    print()
    print(".envÊñá‰ª∂ÈÖçÁΩÆ:")
    print("  Â§çÂà∂ .env.example ‰∏∫ .env Âπ∂Â°´ÂÜôÈÖçÁΩÆ")
    print("  TELEGRAM_BOT_TOKEN=‰Ω†ÁöÑBot Token")
    print("  TELEGRAM_USER_ID=‰Ω†ÁöÑÁî®Êà∑ID")

def main():
    """‰∏ªÂáΩÊï∞"""
    if len(sys.argv) < 2 or sys.argv[1] in ['--help', '-h']:
        show_help()
        sys.exit(0)
    
    # Ëß£ÊûêÂèÇÊï∞
    input_path = sys.argv[1]
    
    config = StickerConfig()
    open_telegram = False
    
    args = sys.argv[2:]
    i = 0
    while i < len(args):
        if args[i] == '--pack-name' and i + 1 < len(args):
            config.pack_name = args[i + 1]
            i += 2
        elif args[i] == '--format' and i + 1 < len(args):
            fmt = args[i + 1]
            if fmt in ['static', 'webm', 'auto']:
                config.preferred_format = fmt
                config.auto_format = (fmt == 'auto')
            else:
                print(f"‚ùå Êó†ÊïàÊ†ºÂºè: {fmt}ÔºåÊîØÊåÅ: static, webm, auto")
                sys.exit(1)
            i += 2
        elif args[i] == '--emoji' and i + 1 < len(args):
            config.emojis = [args[i + 1]]
            i += 2
        elif args[i] == '--output-dir' and i + 1 < len(args):
            config.output_dir = args[i + 1]
            i += 2
        elif args[i] == '--open-telegram':
            open_telegram = True
            i += 1
        elif args[i] == '--upload':
            config.auto_upload = True
            i += 1
        elif args[i] == '--bot-token' and i + 1 < len(args):
            config.bot_token = args[i + 1]
            config.auto_upload = True  # Ëá™Âä®ÂêØÁî®‰∏ä‰º†
            i += 2
        elif args[i] == '--user-id' and i + 1 < len(args):
            try:
                config.user_id = int(args[i + 1])
            except ValueError:
                print(f"‚ùå Êó†ÊïàÁöÑÁî®Êà∑ID: {args[i + 1]}")
                sys.exit(1)
            i += 2
        else:
            i += 1
    
    # Âä†ËΩΩ .env Êñá‰ª∂ÈÖçÁΩÆ
    env_vars = load_env_file()
    
    # Â§ÑÁêÜTelegram‰∏ä‰º†ÈÖçÁΩÆ
    if config.auto_upload:
        # ‰ªé .env Êñá‰ª∂ÊàñÁéØÂ¢ÉÂèòÈáèËé∑Âèñ Bot Token
        if not config.bot_token:
            config.bot_token = (
                env_vars.get('TELEGRAM_BOT_TOKEN', '') or 
                os.getenv('TELEGRAM_BOT_TOKEN', '')
            )
        
        # ‰ªé .env Êñá‰ª∂ÊàñÁéØÂ¢ÉÂèòÈáèËé∑ÂèñÁî®Êà∑ID
        if not config.user_id:
            user_id_str = (
                env_vars.get('TELEGRAM_USER_ID', '') or 
                os.getenv('TELEGRAM_USER_ID', '')
            )
            if user_id_str:
                try:
                    config.user_id = int(user_id_str)
                except ValueError:
                    print(f"‚ùå .env Êñá‰ª∂‰∏≠ÁöÑÁî®Êà∑IDÊ†ºÂºèÈîôËØØ: {user_id_str}")
                    sys.exit(1)
        
        # Â∫îÁî® .env Êñá‰ª∂‰∏≠ÁöÑÂÖ∂‰ªñÈÖçÁΩÆ
        if not config.pack_name or config.pack_name == "MyCustomStickers":
            pack_prefix = env_vars.get('PACK_NAME_PREFIX', '')
            if pack_prefix:
                config.pack_name = pack_prefix
        
        if not config.emojis or config.emojis == ["üòÄ"]:
            default_emoji = env_vars.get('DEFAULT_EMOJI', '')
            if default_emoji:
                config.emojis = [default_emoji]
        
        # È™åËØÅ‰∏ä‰º†ÂèÇÊï∞
        if not config.bot_token:
            print("‚ùå Ëá™Âä®‰∏ä‰º†ÈúÄË¶ÅBot Token")
            print("üí° ÊñπÂºè1: ‰ΩøÁî® --bot-token TOKEN ÂèÇÊï∞")
            print("üí° ÊñπÂºè2: Âú® .env Êñá‰ª∂‰∏≠ËÆæÁΩÆ TELEGRAM_BOT_TOKEN=your_token")
            print("üí° ÊñπÂºè3: ËÆæÁΩÆÁéØÂ¢ÉÂèòÈáè TELEGRAM_BOT_TOKEN")
            print("üìù Ëé∑ÂèñToken: ‰∏é@BotFatherÂØπËØùÂàõÂª∫Bot")
            sys.exit(1)
        
        if not config.user_id:
            print("‚ùå Ëá™Âä®‰∏ä‰º†ÈúÄË¶ÅÁî®Êà∑ID")
            print("üí° ÊñπÂºè1: ‰ΩøÁî® --user-id ID ÂèÇÊï∞")
            print("üí° ÊñπÂºè2: Âú® .env Êñá‰ª∂‰∏≠ËÆæÁΩÆ TELEGRAM_USER_ID=your_id")
            print("üí° ÊñπÂºè3: ËÆæÁΩÆÁéØÂ¢ÉÂèòÈáè TELEGRAM_USER_ID")
            print("üìù Ëé∑ÂèñÁî®Êà∑ID: ‰∏é@userinfobotÂØπËØùËé∑Âèñ‰Ω†ÁöÑTelegram ID")
            sys.exit(1)
    
    # ÂàõÂª∫Âà∂‰ΩúÂô®
    maker = TelegramStickerMaker(config)
    
    # Êî∂ÈõÜËæìÂÖ•Êñá‰ª∂
    input_files = []
    if os.path.isfile(input_path):
        input_files = [input_path]
    elif os.path.isdir(input_path):
        for ext in ['*.gif', '*.png', '*.webp', '*.jpg', '*.jpeg', '*.mp4', '*.webm']:
            import glob
            input_files.extend(glob.glob(os.path.join(input_path, ext)))
            input_files.extend(glob.glob(os.path.join(input_path, ext.upper())))
    
    if not input_files:
        print(f"‚ùå Êú™ÊâæÂà∞ÊîØÊåÅÁöÑÊñá‰ª∂: {input_path}")
        sys.exit(1)
    
    print(f"üéØ TelegramË°®ÊÉÖÂåÖÂà∂‰ΩúÂô®")
    print(f"üì• ËæìÂÖ•Êñá‰ª∂: {len(input_files)} ‰∏™")
    print(f"üì¶ Ë°®ÊÉÖÂåÖÂêçÁß∞: {config.pack_name}")
    print(f"üé® Ê†ºÂºèÁ≠ñÁï•: {config.preferred_format if not config.auto_format else 'auto'}")
    if config.auto_upload:
        print(f"üöÄ Ëá™Âä®‰∏ä‰º†: ÂêØÁî® (Áî®Êà∑ID: {config.user_id})")
    print()
    
    # ÂàõÂª∫Ë°®ÊÉÖÂåÖ
    results = maker.create_sticker_pack(input_files, config.pack_name)
    
    # Ëá™Âä®‰∏ä‰º†Âà∞Telegram
    upload_result = None
    if config.auto_upload and results['successful'] > 0:
        upload_result = maker.upload_to_telegram(results)
    
    # ÊòæÁ§∫ÁªìÊûú
    print("\n" + "="*50)
    print("üìä Âà∂‰ΩúÁªìÊûú")
    print("="*50)
    print(f"‚úÖ ÊàêÂäü: {results['successful']} ‰∏™")
    print(f"‚ùå Â§±Ë¥•: {results['failed']} ‰∏™")
    print(f"üìÅ ËæìÂá∫ÁõÆÂΩï: {results['output_dir']}")
    
    if results['successful'] > 0:
        print(f"\nüìã ÁîüÊàêÁöÑË°®ÊÉÖÂåÖ:")
        format_counts = {}
        for sticker in results['stickers']:
            fmt = sticker['format']
            if fmt not in format_counts:
                format_counts[fmt] = 0
            format_counts[fmt] += 1
            
            file_name = os.path.basename(sticker['output_path'])
            file_size = sticker['file_size'] / 1024
            print(f"  {fmt.upper()}: {file_name} ({file_size:.1f}KB)")
        
        print(f"\nüìà Ê†ºÂºèÁªüËÆ°:")
        for fmt, count in format_counts.items():
            print(f"  {fmt.upper()}: {count} ‰∏™")
        
        # ÊòæÁ§∫‰∏ä‰º†ÁªìÊûú
        if upload_result:
            print(f"\nüöÄ Telegram‰∏ä‰º†ÁªìÊûú:")
            if upload_result['success']:
                print(f"‚úÖ ‰∏ä‰º†ÊàêÂäüÔºÅ")
                print(f"üì± ÂàÜ‰∫´ÈìæÊé•: {upload_result['pack_url']}")
                print(f"üìä ‰∏ä‰º†: {upload_result['uploaded_count']} ‰∏™ÔºåÂ§±Ë¥•: {upload_result['failed_count']} ‰∏™")
            else:
                print(f"‚ùå ‰∏ä‰º†Â§±Ë¥•: {upload_result['message']}")
        
        # ÊâìÂºÄTelegramÂØºÂÖ•
        if open_telegram and not upload_result:
            maker.open_telegram_import(results['output_dir'])
    
    print(f"\nüéâ Ë°®ÊÉÖÂåÖÂà∂‰ΩúÂÆåÊàêÔºÅ")
    if upload_result and upload_result['success']:
        print(f"üéâ Â∑≤Ëá™Âä®‰∏ä‰º†Âà∞TelegramÔºÅ")
        print(f"üì± Á´ãÂç≥ÂàÜ‰∫´: {upload_result['pack_url']}")
    else:
        print(f"üì± ÊâãÂä®ÂØºÂÖ•: ÊâìÂºÄTelegram ‚Üí @stickers ‚Üí /newpack")


if __name__ == '__main__':
    main()